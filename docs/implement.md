# PyCIMsim

# 设计思路

本模拟器采用事件驱动架构对处理器内部行为进行模拟，其融合了电路级模拟和行为级模拟，执行速度快，灵活性强。

## 事件驱动模拟架构

我们需要在串行执行的处理器上模拟并发的行为，为此我们借助离散事件驱动模拟(Discrete Event-Driven Simulation)架构来解决这一问题。事件表示一个行为的发生，在本模拟器中，事件拥有两个属性，分别是时间戳和回调函数，时间戳表示事件应该发生的时刻，在该时刻我们执行回调函数，表示事件的发生。我们使用优先队列存放所有的事件，并按照事件的时间戳排序，每次从队列中时间戳最小的事件，然后将整体的时间同步为该事件的时间戳，然后执行回调函数，在回调函数中我们可能向队列中插入新的事件，如此模拟进程可以持续下去，直到队列为空。为了模拟存在依赖关系，但是并发的行为，我们引入了delta时间来解决这一问题，时间为t+Δt的事件在t时间的事件之后执行，但是我们认为所有这些事件都是在t事件的发生，在代码中epsilon就是delta时间。

在代码中，我们使用堆作为优先队列的实现，同时使用set确保队列中没有重复的事件（可以在后续的改进中去掉）

## 电路级模拟

电路级模拟期望实现类似Verilog仿真器的行为，我们需要编写类似于Verilog的电路描述代码，定义处理器各个部件的电路级行为，然后模型器会按照电路描述执行，得出各个信号的值。

这一部分在circuit模块中实现，本模拟器实现了Wire类，其行为与Verilog中的wire类型相似，表示一根信号线。Wire类的实现思想是一旦wire中存储的值发生变化就在下一个Δ时间调用以该信号为输入的函数，具体可以参考verilog仿真器对wire的实现。

此外本模拟器还实现了register类，该类表示一个寄存器，与verilog不同，该寄存器的输入发生变化就会在下一个时钟周期发生改变，并调用以该寄存器为输入的回调函数，不需要像verilog中使用always语句进行定义，同时所有寄存器默认在上升沿进行更新。

在本模拟器中，wire和register类能承载的数据是任意类型的，所以我们可以把一个模块需要的数据打包处理，对数据的处理也是高度自由的，直接使用python的方法处理即可，wire和register主要保证并发行为和时序正确。

## 行为级模拟

对于Memory，NoC等更高维度的模拟，如果全部使用电路实现会比较困难，因此采取行为级模拟的方式进行模拟。

本模拟器通过一个状态机将行为级模拟与电路级模拟隔离开，在状态机的一个状态上表示开始行为级模拟，不在更新电路数据，行为执行完毕后重新将状态机状态改回，重新接收新的电路数据。行为级模拟中一个数据的传输只需要添加延迟即可实现，比如传输一个数据需要10tick，那么插入一个+10tick的事件即可表示传输完成。